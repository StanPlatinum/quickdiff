\section{Background}\label{sec-background}

\noindent\textbf{Intel SGX}. Intel SGX~\cite{mckeen2013innovative} is a user-space TEE, which is characterized by flexible process-level isolation. Such protection, however, comes with in-enclave resource constraints. Particularly, only 128 MB (256 MB for some new processors) encryption protected memory is reserved. Although virtual memory support is available, it incurs significant overheads in paging~\cite{arnautov2016scone}. 


 %In fact, due to the memory encryption engine carved from the EPC memory and the lingering of SGX SDK, there is around 90 MB physical memory that could be allocated for user programs.
Another problem caused by SGX's design is a large attack surface. The application can invoke a pre-defined function inside the enclave, passing input parameters and pointers to shared memory within the application. Those invocations from the application to the enclave are called ECall. When an enclave executes, it can perform an OCall to a pre-defined function in the application. Contrary to an ECall, an OCall cannot share enclave memory with the application, so it must copy the parameters into the application memory before the OCall. When an enclave program contains memory vulnerabilities, attacks can happen to compromise enclave's privacy protection. Prior research demonstrates that a Return-oriented programming (ROP) attack can succeed in injecting malicious code inside an enclave, which can be launched by the OS, Hypervisor, or BIOS~\cite{lee2017hacking,biondo2018guard,schwarz2019practical}. %Deploying the Control flow integrity (CFI) in the enclave also needs to consider the SGX-specific features~\cite{lee2017hacking}.
Another security risk is side-channel leak~\cite{schwarz2017malware,lee2017inferring,gras2018translation}, caused by the thin software stack inside an enclave (for reducing TCB),  which often has to resort to the OS for resource management (e.g., paging, I/O control). Particularly, an OS-level adversary can perform a controlled side channel attack (e.g.,~\cite{xu2015controlled}).
%Also in the threat model is the physical adversary, such as a system administrator, who tries to gain unauthorized access to a TEE’s computing units to compromise its integrity or confidentiality.

%\weijie{remove this paragraph}
%\vspace{3pt}\noindent\textbf{SGX remote attestation}. As mentioned earlier, attestation allows a remote user to verify that the enclave is correctly constructed and run on a genuine SGX-enabled platform. In Intel’s attestation model, three parties are involved: (1) the Independent Software Vendor (ISV) who is registered to Intel as the enclave developer; (2) the Intel Attestation Service (IAS) hosted by Intel to help enclave verification,
%\footnote{SGX now supports both the Intel Enhanced Privacy ID (Intel EPID) based Intel Attestation Service (IAS) and the Elliptic Curve Digital Signature Algorithm (ECDSA) based third-party attestation with Intel SGX Data Center Attestation Primitives (Intel SGX DCAP) to generate and verify the quote. The signing and verifying algorithms are orthogonal to the main part of the paper.}
%and for simplicity we assume the IAS based attestation is used.}
%and (3) the SGX-enabled platform that operates SGX enclaves. The attestation begins with the ISV sending an attestation request challenge, which can be generated by an enclave user or a data owner who wants to perform the attestation with the enclave to check its state. Upon recipient of the challenge, the enclave then generates a verification report including the enclave measurement, which can be verified by a quoting enclave (QE) through \textit{local attestation}. The QE signs the report using the attestation key and the generated \textit{quote} is forwarded to the Intel Attestation Service (IAS). 
%The IAS then checks the quote and signs the verification result using Intel's private key. The ISV can then validate the attestation result based upon the signature and the enclave measurement.

%\weijie{shrink and rewrite the following subsection}

\vspace{3pt}\noindent\textbf{PCC}. PCC is a mechanism that allows a host system to verify an application's properties with a proof accompanying the application's executable code.
Traditional PCC schemes tend to utilize formal verification for proof generation and validation. Techniques for this purpose includes verification condition generation~\cite{homeier1995mechanically,colby2000certifying}, theorem proving~\cite{paulson2000isabelle,de2008z3,bertot2013interactive}, and proof checking~\cite{appel2003trustworthy}, which typically work on type-safe intermediate languages (IL) or higher level languages. A problem here is that up to our knowledge, no formal tool today can automatically transform a binary to IL for in-enclave verification. BAP~\cite{brumley2011bap} disassembles binaries and lifts x86 instructions to a formal format, but it does not have a runtime C/C++ library for static linking, as required for an enclave program.
Moreover, the PCC architecture relies on the correctness of the VCGen and the proof checker, so a direct application of PCC to confidential computing needs to include both in TCB. This is problematic due to their complicated designs and implementations, which are known to be error-prone~\cite{necula2001oracle}. Particularly, today's VCGens are built on either an interpreter/compiler even a virtual machine~\cite{leroy2006formal}, and therefore will lead to a huge TCB. Prior attempts~\cite{appel2001foundational} to move VCGen out of TCB are found to have serious performance impacts, due to the significantly increased proof size growing exponentially with the size of the program that needs to be certified~\cite{necula1997proof}. \ignore{ It is common to have a proof 1000 times larger than the code~\cite{pirzadeh2010extended}. The proof/certificate in PCC is a formal representation that can be encoded as e.g. LF term. Such proof terms include a lot of repetition which means it includes huge certificates. } Although techniques are there to reduce the proof size~\cite{appel2001foundational,pirzadeh2010extended},\ignore{ e.g. OPCC introduces a non-deterministic proof checker that makes the proof 30 times smaller. However, } they are too complicated to scale to real-world applications~\cite{appel2003trustworthy}. 
%Therefore as far as we are aware, no existing PCC techniques can be directly applied to enable the CAT model on today's TEE. 

\section{Discussion}\label{sec-discussion}

%In previous sections we have shown that the design of CAT offers lightweight and efficient in-enclave verification of privacy policy compliance. 
%Here we discuss some extensions.

%\subsection{Preventing Side Channels}

%Side/covert channel often hides in the normal behaviors during program execution. Since the logic of service providerâ€™s code would be very complicated, even if we could instrument all parts which needs to be protected, and guarantee the completeness of CFI policies if we do not apply side channel defenses.

%Although as described, side channel/covert channel issues are not considered in this paper, we still want to acclaim that side channel defense like CosMIX~\cite{orenbach2019cosmix} can be incorporated into our framework.
\vspace{3pt}\noindent\textbf{Supporting other side/covert channel defenses}.\label{subsec:morescenario}
The framework of our system is highly flexible, which means assembling new policies into current design can be very straightforward.
In Section~\ref{subsec-producer}, we talked about policy enforcement approaches for side channel resilience.
It demonstrated that our framework can take various side channel mitigation approaches to generate code carried with proof. Besides AEX based mitigations which we learnt from Hyperrace~\cite{chen2018racing}, others~\cite{doychev2015cacheaudit,almeida2016verifying,shih2017t,gruss2017strong,wu2018eliminating,wang2019identifying,orenbach2019cosmix} can also be transformed and incorporated into the design, \revise{specifically for mitigating cache timing, memory bus timing~\cite{liu2015can}, and other timing channels.}
\revise{ORAM~\cite{sasy2017zerotrace,ahmad2019obfuscuro} can also be integrated to \textsc{Deflection} as a policy, to relieve memory access based side- or covert- channel leakage to some extend.}
Additionally, policies such as \textit{on-demand aligning/blurring processing time} can be added for preventing processing-time based covert channels~\cite{liu2017demand}.
Even though new attacks have been kept being proposed and there is perhaps no definitive and practical
solutions to all side/covert channel attacks, we believe eventually some efforts can be integrated in our work, even using SGXv2~\cite{orenbach2020autarky}.

\ignore{
Other on-demand policies against newly-published security flaws can be appended/withdrawn to serve various goals. \textsc{Deflection} can make the quick patch possible on software level, just like the way people coping with 1-day vulnerabilities - emergency fix. 
}

%System calls may create covert channels, which also can be eliminated with more stricter policies such as fixing system call intervals.

%\weijie{Autarky: Closing controlled channels with self-paging enclaves}
%\weijie{transient execution attacks could be mitigated using other policies (e.g., inserting mfence/lfence to the service binary code)}

%\subsection{Other information leakage via deliberate interrupts issued from malicious OS}

%\vspace{3pt}\noindent\textbf{Supporting multi-user}.
%Currently we support single data owner scenarios. Of course for multi-user scenarios, we can easily add a data cleansing policy which ensures that once the task for one data owner ends, all her data will be removed from the enclave before the next owner's data is loaded, together with the content of SSA and registers, while not destroying the bootstrap enclave after use.
%Further, to fully support multi-user in-enclave services, we need to ensure each data owner's session key remains secret and to conduct remote attestation for data owners when they switch. Hardware features like Intel MPX~\cite{shen2018isolate} can be additionally applied to enforce memory permission integrity~\cite{zhao2020mptee}, as a supplementary boundary checking policy.



\vspace{3pt}\noindent\textbf{Supporting multi-threading}.
\revise{SGX supports multi-threaded execution. To concurrently service many clients, policies such as isolating each thread's private memory and setting read-only permissions on cross-thread shared memory can be enforced.}
Multi-threading could introduce serious bugs~\cite{weichbrodt2016asyncshock}. The proof enforcement of CFI may suffer from a time of check to time of use (TOCTOU) problem~\cite{xu2019confirm}.
To cope with that, we can make all CFI metadata to be kept in the register or hardware~\cite{delozier2020hurdle} instead of in memory, and guarantee that the instrumented proof could not be modified by any threads~\cite{burow2019sok}. 

%When taking multi-threading into account, the proof generation process become more complicated and cumbersome~\cite{guo2007certified}.
%\weijie{other issues}\cite{zhao2020mptee}\cite{shen2020occlum}




%\weijie{Of course, preventing memory read operations from other threads can take the multi-threading leakage once and for all. However, we do not apply this policy since it is too heavy. By enforcing enforcing policies from P1 to P5,  outside the enclave except via legitimate Ocalls.}

%Note that even we can prevent reads from other threads, that is not enough. If we don't prevent attacks mentioned in CONFirm, \weijie{multithread CFI issue}, the CFI is still broken. \weijie{enforcing P5 also cannot eliminate the threat of multi-thread CFI issue.} Therefore, we use TSX to wrap the checking code. \weijie{We need to discuss: more than 1 SSA/TLS and concurrent execution.}

%\wenhao{1. it seems that we do not need to audit memory loads, since it cannot leak; 2. , multi-thread CFI issues does not exist, as one thread cannot modify the CFI metadata? 

%\vspace{3pt}\noindent\textbf{Supporting on-demand policies}.



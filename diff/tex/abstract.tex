\begin{abstract}

A trusted execution environment (TEE) such as Intel Software Guard Extension (SGX) runs attestation to prove to a data owner the integrity of the initial state of an enclave, including the program to operate on her data. For this purpose, the data-processing program is supposed to be open to the owner or a trusted third party, so its functionality can be evaluated before trust being established. In the real world, however, increasingly there are application scenarios in which the program itself needs to be protected (e.g., proprietary algorithm). So its compliance with privacy policies as expected by the data owner should be verified without exposing its code. 


To this end, this paper presents \textsc{Deflection}, a new model for TEE-based \revise{delegated and flexible in-enclave code verification}. Given that the conventional solutions do not work well under the resource-limited and TCB-frugal TEE, we come up with a new design inspired by Proof-Carrying Code\DIFdelbegin \DIFdel{that allows an untrusted out-enclave generator to analyze and instrument the source code of a program when compiling it into binary and a trusted in-enclave consumer efficiently verifies the correctness of the instrumentation and the presence of other protection before running the binary.
}\DIFdelend \DIFaddbegin \DIFadd{.
%DIF >  that allows an untrusted out-enclave generator to analyze and instrument the source code of a program when compiling it into binary and a trusted in-enclave consumer efficiently verifies the correctness of the instrumentation and the presence of other protection before running the binary. 
}\DIFaddend Our design strategically moves most of the workload to the code generator, which is responsible for producing easy-to-check code, while keeping the consumer simple. Also, the whole consumer can be made public and verified through a conventional attestation. We implemented this model on Intel SGX and demonstrate that it introduces a very small part of TCB. We also thoroughly evaluated its performance on micro- and macro- benchmarks and real-world applications, showing that the design only incurs a small overhead when enforcing several categories of security policies.



%technology using Intel SGX for multiple scenarios. CAT is designed with a Proof-Carrying Code (PCC) concept composed of an LLVM-based code producer and Intel SGX-based code consumer. We implement CAT and thoroughly evaluate it on real SGX hardware. It can effectively prevent data breaches and preserve code confidentiality at the same time. Moreover, the TCB of our design is smaller than mostly related approaches. Performance evaluation shows low overhead (about 18\% on average) in running common micro-benchmarks and acceptable overhead (less than 23\% on average) in running more realistic workloads.
%Security analysis elaborates that attackers only have very limited ways to leakage data and

\end{abstract}

% for Oakland
%\begin{IEEEkeywords}
%Intel SGX, PCC, Confidentiality, Verification
%\end{IEEEkeywords}
\DIFaddbegin 

\begin{IEEEkeywords}
\DIFadd{Intel SGX, Confidential Computing, Proof-Carrying Code, Enclave Shielding Runtime
}\end{IEEEkeywords}
\DIFaddend 


%Intel Software Guard Extension (SGX) has been studied widely for protecting data and code under many circumstances, especially on cloud computing platforms. Data owners always want their data to be used in a highly secure way, so SGX is naturally a practical and effective way that can be leveraged in such scenarios. Intel SGX provides a relatively trustworthy execution environment for preventing data from being observed by the outside world. This crucial step requires remote attestation protocols, and meanwhile, the service provider's code needs to be exposed. However, service providers may not want their data-processing code to be public.

%To address the dilemma, this paper presents CAT, a new practical confidential attestation technology using Intel SGX for multiple scenarios. CAT is designed with a Proof-Carrying Code (PCC) concept composed of an LLVM-based code producer and Intel SGX-based code consumer. We implement CAT and thoroughly evaluate it on real SGX hardware. It can effectively prevent data breaches and preserve code confidentiality at the same time. Moreover, the TCB of our design is smaller than mostly related approaches. Performance evaluation shows low overhead (about 18\% on average) in running common micro-benchmarks and acceptable overhead (less than 23\% on average) in running more realistic workloads.